Routování
*********

<div class=perex>

Router má na starosti vše kolem podoby URL adres, aby vy už jste nad nimi nemuseli přemýšlet. Ukážeme si:

- jak nastavit router, aby URL byly podle vašich představ
- povíme si o SEO a přesměrování
- a ukážeme si, jak napsat vlastní router

</div>


Lidštější URL (nebo taky cool, pretty či user-friendly URL) jsou použitelnější a zapamatovatelnější a pozitivně přispívají k SEO((optimalizaci nalezitelnosti na internetu)). Nette Framework na to myslí a vychází vývojářům plně vstříc.

Začneme technicky. Router je objekt implementující rozhraní [api:Nette\Routing\Router], který umí rozložit URL na pole parametrů (metoda `match()`) a obráceně z pole parametrů sestavit URL (metoda `constructUrl()`). Proto se taky říká, že router je obousměrný.
Nette dává možnost velice elegantním způsobem definovat pravidla, jak přesně má router fungovat, tedy, jak mají URL naší aplikace vypadat.

Router se obvykle používá v kombinaci s [Nette Application|application#Nette Application], která se získaným polem parametrů dále pracuje, zejména tedy s parametry `presenter`, `action` a `do`, které určují presenter, akci a signál.
A dále využívá router pro generování URL v šabloně, kde zapíšeme třeba:

```html
<a n:href="Product:detail $productId">detail produktu</a>
```

a router už sám sestaví z těchto parametrů URL. Více se dočtete v kapitole [vytváření odkazů |link-generation].

Ovšem router není limitován pro tohle využití, můžete jej úplně stejně použít pro jakékoliv jiné nasazení, pro REST API, pro aplikace, kde se vůbec presentery nepoužívají atd. Více v části [#samostatné použití].

Routování tedy představuje samostatnou a velmi pokrokovou vrstvu aplikace. Díky němu můžeme tvary URL vymýšlet klidně až ve chvíli, když je celá aplikace hotová. Stejně tak je velmi snadné je kdykoliv změnit. Což dává vývojářům obrovskou svobodu.


Kolekce rout
============

Nejpohodlnější způsob, jak definovat podobu URL, dává třída `Nette\Routing\RouteList`, resp. její potomek `Nette\Application\Routers\RouteList`, který navíc doplňuje podporu pro presentery, což se nám hodí. Velkou výhodou je, že celý router
se definuje na jednom místě pomocí PHP kódu a není tak roztroušen ve formě anotací v jednotlivých presenterech.

Základem je definice tzv. rout, tedy jednotlivých adres URL a k nim přidružených presenterů a akcí pomocí jednoduchého API:

```php
$router = new Nette\Application\Routers\RouteList;
// URL https://example.com/article/123  zavolá Article:view a id=123
$router->addRoute('article/<id>', 'Article:view');
// URL https://example.com/rss.xml  zavolá Feed:rss
$router->addRoute('rss.xml', 'Feed:rss');
```

Všimněte si, že routy nemusíme nijak pojmenovávat.

Abychom takto vytvořený router zapojili do celé aplikace, musíme o něm říct DI kontejneru. Nejsnazší cesta je připravit továrnu, která objekt routeru vyrobí, a sdělit v konfiguraci kontejneru, aby ji použil. Tak dejme tomu, že vyrobíme metodu `App\Router\RouterFactory::createRouter()`:

```php
namespace App\Router;

use Nette\Application\Routers\RouteList;

class RouterFactory
{
	public static function createRouter(): RouteList
	{
		$router = new RouteList;
		$router->addRoute(...);
		return $router;
	}
}
```

A do konfiguračního souboru zapíšeme:

```neon
services:
	router: App\Router\RouterFactory::createRouter
```

Jakékoliv závislosti, třeba na databázi atd, lze předávat do tovární metody jako její parametry:

```php
public static function createRouter(Nette\Database\Connection $db, bool $debugMode = false): RouteList
{
	...
}
```

V případě nenalezení routy se vyhodí výjimka [BadRequestException |api:Nette\Application\BadRequestException], která se uživateli zobrazí jako stránka 404 Not Found.


Maska cesty
-----------

RouterList je možné použít k vytváření adres libovolného tvaru. Popisují se pomocí tzv. rout, jejímž prvním parametrem je maska cesty a druhým výchozí akce presenteru zapsaná jako řetězec nebo pole. Třetím parametrem může být [příznak|#Jednosměrky ONE_WAY].

Nejjednodušší maskou je **statická URL** s uvedenou cílovou akcí presenteru.

```php
$router->addRoute('products', 'Products:default');
```

Většina reálných masek však obsahuje proměnlivé **parametry**. Ty jsou uvedeny ve špičatých závorkách (např. `<year>`) a jsou předány do cílového presenteru.

```php
$router->addRoute('history/<year>', 'History:view');
```

Často se používají univerzální routy, jako například tato, kde výchozí akcí bude presenter Homepage a akce default:

```php
$router->addRoute('<presenter>/<action>[/<id>]', 'Homepage:default');
```

Uvedená routa je použitelná pro libovolné presentery a akce. Akceptuje cestu např. ve tvaru `/article/edit/10` nebo také `/catalog/list`, protože část s parameterem `id` je uzavřena do hranatých závorek, čímž říkáme, že je nepovinná.

Protože i ostatní parametry (presenter, action) mají výchozí hodnotu (tj. `Homepage` a `default`), jsou volitelné. Pokud jejich hodnota bude shodná s výchozí, v URL se vynechají. Takže odkaz na `Product:default` vygeneruje cestu `/product`, odkaz na výchozí `Homepage:default` cestu `/`.

Maska může popisovat nejen relativní cestu od kořenového adresáře webu, ale také absolutní cestu (pokud začíná lomítkem) nebo dokonce celé absolutní URL (začíná-li dvěma lomítky):

```php
// relativně k document rootu (složka www)
$router->addRoute('<presenter>/<action>', ...);

// absolutní cesta (relativní k doméně)
$router->addRoute('/<presenter>/<action>', ...);

// absolutní URL včetně domény (relativní k schématu)
$router->addRoute('//<subdomain>.example.com/<presenter>/<action>', ...);

// absolutní URL včetně schématu
$router->addRoute('https://<subdomain>.example.com/<presenter>/<action>', ...);
```

.[caution]
Je důležité, v jakém pořadí jsou routy definovány, protože se zkouší postupně odshora dolů. Platí pravidlo, že **routy deklarujeme od specifických po obecné**.

Pamatujte na to, že počet rout má vliv na rychlost aplikace, zejména při generování odkazů. Proto se vyplatí routovací tabulku zjednodušit.


Výchozí hodnoty
---------------

Jednotlivým parametrům můžeme určit výchozí hodnotu přímo v masce:

```php
$router->addRoute('<presenter=Homepage>/<action=default>/<id=>');
```

Nebo pomocí pole:

```php
use Nette\Routing\Route;

$router->addRoute('<presenter>/<action>/<id>', [
	'presenter' => 'Homepage',
	'action' => 'default',
	'id' => null,
]);

// je ekvivalentní s touto delší notací
$router->addRoute('<presenter>/<action>/<id>', [
	'presenter' => [
		Route::VALUE => 'Homepage',
	],
	'action' => [
		Route::VALUE => 'default',
	],
	'id' => [
		Route::VALUE => null,
	],
]);
```

Výchozí hodnoty pro `<presenter>` a `<action>` mohou být také zapsány jako řetězec v druhém parametru konstruktoru:

```php
$router->addRoute('<presenter>/<action>/<id=>', 'Homepage:default');
```


Validační výrazy
----------------

Dále lze určit validační podmínku pomocí regulárního výrazu. Například parametru `id` určíme, že může nabývat pouze číslic pomocí validační podmínky `[0-9]+`:

```php
use Nette\Routing\Route;

// regexp lze definovat přímo v masce cesty po názvu parametru
$router->addRoute('<presenter>/<action>[/<id \d+>]', 'Homepage:default');

// je ekvivalentní s touto delší notací
$router->addRoute('<presenter>/<action>[/<id>]', [
	'presenter' => 'Homepage',
	'action' => 'default',
	'id' => [
		Route::PATTERN => '\d+',
	],
]);
```

.[note]
Výchozí validační podmínkou je `[^/]+`, tj. vše kromě lomítka. Pokud má parametr přijímat i lomítka, uvedeme podmínku `.+`.


Volitelné sekvence
------------------

V masce lze označovat volitelné části pomocí hranatých závorek. Volitelná může být libovolná část masky, mohou se v ní nacházet i parametry:

```php
$router->addRoute('[<lang [a-z]{2}>/]<name>', 'Article:view');

// Akceptuje cesty:
//    /cs/download  => lang => cs, name => download
//    /download     => lang => null, name => download
```

Když je parametr součásti volitelné sekvence, stává se pochopitelně také volitelným s výchozí hodnotou null. Sekvence zároveň definuje jeho okolí, v tomto případě znak lomítka, které musí za parametrem, je-li uveden, následovat. Této techniky lze využít například u volitelných subdomén s jazykem:

```php
$router->addRoute('//[<lang=en>.]example.com/<presenter>/<action>', ...);
```

Sekvence je možné libovolně zanořovat a kombinovat:

```php
$router->addRoute(
	'[<lang [a-z]{2}>[-<sublang>]/]<name>[/page-<page=0>]',
	'Homepage:default'
);

// Akceptuje cesty:
// 	/cs/hello
// 	/en-us/hello
// 	/hello
// 	/hello/page-12
```


Při generování URL se usiluje o nejkratší URL, takže všechno, co lze vynechat, se vynechá. Proto třeba routa `index[.html]` generuje cestu `/index`. Obrátit chování je možné uvedením vykřičníku za levou hranatou závorkou:

```php
// akceptuje /hello i /hello.html, generuje /hello
$router->addRoute('<name>[.html]');

// akceptuje /hello i /hello.html, generuje /hello.html
$router->addRoute('<name>[!.html]');
```


Volitelné parametry (tj. parametry mající výchozí hodnotu) bez hranatých závorek se chovají v podstatě tak, jako by byly uzávorkovány následujícím způsobem:

```php
$router->addRoute('<presenter=Homepage>/<action=default>/<id=>');

// odpovídá tomuto:
$router->addRoute('[<presenter=Homepage>/[<action=default>/[<id>]]]');
```

Pokud bychom chtěli ovlivnit chování koncového lomítka, aby se např. místo `/homepage/` generovalo jen `/homepage`, lze toho docílit takto:

```php
$router->addRoute('[<presenter=Homepage>[/<action=default>[/<id>]]]');
```


Zástupné znaky
--------------

V masce absolutní cesty můžeme použít následující proměnné:
- `%tld%` = top level domain, např. `com` nebo `org`
- `%sld%` = second level domain, např. u `example.com` vrací `example`
- `%domain%` = doména bez subdomény, např. `example.com`
- `%host%` = celý host, např. `www.example.com`
- `%basePath%` = absolutní URL cesta ke kořenovému adresáři

```php
$router->addRoute('//www.%domain%/%basePath%/<presenter>/<action>', ...);
$router->addRoute('//www.%sld%.%tld%/%basePath%/<presenter>/<action', ...);
```


Transformace a překlady
-----------------------

Je záhodno psát zdrojové kódy v angličtině, ale co když má web běžet v českém prostředí? Pak jednoduché routování typu:

```php
$router->addRoute('<presenter>/<action>/<id>', [
	'presenter' => 'Homepage',
	'action' => 'default',
	'id' => null,
]);
```

bude generovat anglické URL, jako třeba `/product/123`, `/cart` nebo `/catalog/view` apod. Pokud chceme mít presentery a akce v URL reprezentované českými slovy (např. `/produkt/123` nebo `/kosik`), můžeme využít překladového slovníku. Definice v poli rozšíříme:

```php
use Nette\Routing\Route;

$router->addRoute('<presenter>/<action>/<id>', [
	'presenter' => [
		Route::VALUE => 'Homepage',
		Route::FILTER_TABLE => [
			// řetězec v URL => presenter
			'produkt' => 'Product',
			'kosik' => 'Cart',
			'katalog' => 'Catalog',
		],
	],
	'action' => [
		Route::VALUE => 'default',
		Route::FILTER_TABLE => [
			'sehen' => 'view',
		],
	],
	'id' => null,
]);
```

.[tip]
Jeden presenter může být uveden pod více různými klíči. Pak k němu povedou všechny varianty (tedy vytvoří se aliasy) s tím, že za kanonickou se považuje ta poslední.

Překladovou tabulku lze tímto způsobem aplikovat na jakýkoliv parametr. Přičemž nefunguje jako filtr, tj. pokud překlad existuje, přeloží se, a pokud neexistuje, bere se původní hodnota.

Pokud chceme u parametru použít pouze překladový slovník, přídáme `FILTER_STRICT => true`. Tím docílíme toho, že se budou akceptovat pouze hodnoty ve slovníku.

Kromě překladového slovníku v podobě pole lze nasadit i vlastní překladové funkce a filtry.

```php
$router->addRoute('<presenter>/<action>/<id>', [
	'presenter' => [
		Route::VALUE => 'Homepage',
		Route::FILTER_IN => 'filterInFunc',
		Route::FILTER_OUT => 'filterOutFunc',
	],
	'action' => 'default',
	'id' => null,
]);
```

Kde `filterInFunc` a `filterOutFunc` jsou funkce či metody, jenž převádí mezi parametrem v URL a tvarem, který se předává do presenteru. Každá z nich zajišťuje převod opačným směrem.

Implicitním in-filterem je funkce [rawurldecode |php:rawurldecode] a out-filterem je funkce, která escapuje speciální znaky (například lomítko či mezeru) pro použití v URL.

Jsou situace, kdy toto chování budeme chtít změnit, například pokud použijeme parametr `path`, který může obsahovat i lomítka. Aby se nekonvertovala na sekvence `%2F`, zrušíme filtry:

```php
// akceptuje http://files.example.com/path/to/my/file

$router->addRoute('//files.example.com/<path .+>', [
	'presenter' => 'File',
	'action' => 'default',
	'path' => [
		Route::VALUE => null,
		Route::FILTER_IN => null,
		Route::FILTER_OUT => null,
	],
]);
```


Globální filtry
---------------

Vedle filtrů určených pro konkrétní parametry (`<presenter>`, `<action>`, ...) můžeme definovat též **globální filtry**, které akceptují asociativní pole se všemi parametry a vrací pole vyfiltrovaných parametrů. Globální filtry definujeme pod klíčem `null`.

```php
use Nette\Routing\Route;

$router->addRoute('<presenter>/<action>', [
	'presenter' => 'Homepage',
	'action' => 'default',
	null => [
		Route::FILTER_IN => function (array $params): array {
			// ...
			return $params;
		},
		Route::FILTER_OUT => function (array $params): array {
			// ...
			return $params;
		},
	],
]);
```

.[tip]
Globální filtry můžeme použít též pro filtrování parametrů na základě jiných parametrů. Například přeložení `<presenter>` a `<action>` na základě parametru `<lang>`.


Jednosměrky ONE_WAY
-------------------

Jednosměrné routy se používají zejména pro zachování funkčnosti starých URL, když tvar URL v aplikaci předěláme do novější podoby. Příznakem `ONE_WAY` tedy označíme routy, které se už nepoužívají pro generování URL.

```php
// staré URL /product-info?id=123
$router->addRoute('product-info', 'Product:detail', $router::ONE_WAY);
// nové URL /product/123
$router->addRoute('product/<id>', 'Product:detail');
```

Navíc dojde k automatickému přesměrování na nový tvar URL, takže vám tyto stránky vyhledávače nezaindexují dvakrát (viz [#SEO a kanonizace]).


Moduly
------

Pokud máme více rout, které chceme zařadit do modulu, můžeme využít `withModule()`:

```php
$router = new RouteList;
$router->withModule('Forum') // následující routy jsou součástí modulu Forum
	->addRoute('rss', 'Feed:rss') // presenter bude Forum:Feed
	->addRoute('<presenter>/<action>')

	->withModule('Admin') // následující routy jsou součástí modulu Forum:Admin
		->addRoute('sign:in', 'Sign:in');
```

Také můžeme využít parametr `module` u třídy `Route`:

```php
// URL manage/dashboard/default se mapuje na presenter Admin:Dashboard
$router->addRoute('manage/<presenter>/<action>', [
	'module' => 'Admin'
]);
```

Subdomény
---------

Kolekce rout můžeme členit podle subdomén:

```php
$router = new RouteList;
$router->withDomain('example.com')
	->addRoute('rss', 'Feed:rss')
	->addRoute('<presenter>/<action>');
```

V názvu domény lze použít i [#zástupné znaky]:

```php
$router = new RouteList;
$router->withDomain('example.%tld%')
	...
```

Prefix cesty
------------

Kolekce rout můžeme členit podle cesty v URL:

```php
$router = new RouteList;
$router->withPath('/eshop')
	->addRoute('rss', 'Feed:rss') // chytá URL /eshop/rss
	->addRoute('<presenter>/<action>'); // chytá URL /eshop/<presenter>/<action>
```

Kombinace
---------

Výše uvedené členění můžeme vzájemně kombinovat:

```php
$router = (new RouteList)
	->withDomain('admin.example.com')
		->withModule('Admin')
			->addRoute(...)
			->addRoute(...)
		->end()
		->withModule('Images')
			->addRoute(...)
		->end()
	->end()
	->withDomain('example.com')
		->withPath('export')
			->addRoute(...)
			...
```


Query parametry
---------------

Masky mohou také obsahovat tradiční GET parametry (parametry za otazníkem v URL). Pro tyto však nelze použít validační (např. regulární výraz) a další složitější struktury, nicméně můžeme určit, který parametr bude použit pod jakým názvem v aplikaci:

```php
// říkáme, že GET parameter "cat" chceme v aplikaci použít pod názvem "categoryId"
$router->addRoute('<presenter>/<action> ? id=<productId> & cat=<categoryId>', ...);
```


Foo parametry
-------------

Foo parametry jsou podobné volitelným sekvencím, slouží však k tomu, aby bylo možné do masky přidat regulární výraz. Příkladem je routa akceptující `/index`, `/index.html`, `/index.htm` a `/index.php`:

```php
$router->addRoute('index<? \.html?|\.php|>', 'Homepage:default');
```

Lze také explicitně definovat řetězec, který bude při generování cesty použit (obdoba výchozí hodnoty u skutečných parametrů). Řetězec musí být umístěn přímo za otazníkem. Následující routa je podobná předchozí, ale generuje `/index.html` namísto `/index`, protože řetězec `.html` je nastaven jako výchozí hodnota:

```php
$router->addRoute('index<?.html \.html?|\.php|>', 'Homepage:default');
```



SimpleRouter
============

Mnohem jednodušší variantou než kolekce rout je [SimpleRouter |api:Nette\Application\Routers\SimpleRouter]. Použijeme jej tehdy, pokud nemáme zvláštní nároky na tvar URL, pokud není k dispozici `mod_rewrite` (nebo jeho alternativy) nebo pokud zatím nechceme řešit *hezké* URL.

Generované adresy budou zhruba v tomto tvaru:

```
http://example.com/?presenter=Product&action=detail&id=123
```

Prvním parametrem konstruktoru SimpleRouteru je výchozí akce presenteru, tj. akce, která se má provést, pokud otevřeme stránku např. `http://example.com/` bez dalších parametrů.

```php
// výchozím presenterem bude 'Homepage' a akcí 'default'
$router = new Nette\Application\Routers\SimpleRouter('Homepage:default');
```

Doporučovaným způsobem konfigurace rout v aplikaci je zaregistrování SimpleRouteru v [konfiguračním souboru |configuring#sluzby]:

```neon
services:
	application.router: Nette\Application\Routers\SimpleRouter('Homepage:default')
```


SEO a kanonizace
================

Framework přispívá k SEO (optimalizaci nalezitelnosti na internetu) tím, že zabraňuje existenci duplicitních URL vedoucích na stejný obsah. Pokud k určitému cíli vede více adres, např. `/index` a `/index.html`, framework první z nich určí za výchozí (kanonickou) a ostatní na ni přesměruje pomocí HTTP kódu 301. Díky tomu vám vyhledávače stránky nezaindexují dvakrát a nerozmělní jejich page rank.

Tomuto procesu se říká kanonizace. Výchozí (kanonickou) URL je ta, kterou vygeneruje router, tj. první routa v kolekci bez příznaku ONE_WAY.

Kanonizaci provádí [Presenter |api:Nette\Application\UI\Presenter] a ve výchozím nastavení je zapnutá. Lze ji vypnout přes `$presenter->autoCanonicalize = false`.

.[note]
K přesměrování nedojde při AJAXovém nebo POST požadavku, protože by došlo ke ztrátě dat nebo by to nemělo přidanou hodnotu z hlediska SEO.


HTTPS
=====

Abychom mohli používat HTTPS protokol, je nutné si správně nakonfigurovat server.

Přesměrování všech adres u již zaběhnuté aplikace lze docílit pomocí souboru .htaccess v kořenovém adresáři naší aplikace za použití permanentního přesměrování s kódem 301. (Nastavení se může lišit podle hostingu.)

```php
<IfModule mod_rewrite.c>
	RewriteEngine On
	...
	RewriteCond %{HTTPS} off
	RewriteRule .* https://%{HTTP_HOST}%{REQUEST_URI} [L,R=301]
	...
</IfModule>
```

Routy generují URL se stejným protokolem, s jakým byla stránka načtena, takže nic víc není obvykle pořeba nastavovat.

Pokud ale potřebujeme, aby jednotlivé routy běžely pod různými protokoly, uvedeme ho v masce routy:

```php
// Bude generovat adresu s HTTP
$router->addRoute('http://%host%/<presenter>/<action>','Homepage:default');

// Bude generovat adresu s HTTPs
$router->addRoute('https://%host%/<presenter>/<action>','Admin:default');
```

.[caution]
HTTPS musíte aktivovat u svého hostingu.


Routing Debugger
================

Nebudeme před vámi tajit, že routování je do jisté míry magie a než ji pokoříte, bude vám dobrým pomocníkem Routing Debugger. Jde o panel do [Tracy Bar |tracy:], poskytující přehledný seznam parametrů, které router získal z URL, a také seznamem jednotlivých definovaných rout. Zapíná se automaticky.

Zobrazí, na kterém presenteru & view se aktuálně nacházíte, jaké mu byly předány parametry a také zobrazí tabulku s přehledem všech definovaných cest včetně příznaků, jestli pasují i na aktuální URL:

[* routing-debugger.png *]

Routing debugger je ve výchozím nastavení povolen, pokud aplikace běží v režimu ladění. Můžete ji však vypnout v konfiguračním souboru:

```neon
routing:
	debugger: false # on by default
```


Cachování rout
==============

Pokud router nemá žádné závislosti, například na databázi, a jeho továrna nepřijímá žádné argumenty, můžeme jeho sestavenou podobu nakešovat (konkrétně serializovat jej) přímo do DI kontejneru a tím aplikaci trochu zrychlit.

```neon
routing:
	cache: true
```


Vlastní router
==============

Pokud vám nabízené routery nedostačují, můžete si vytvořit router vlastní a zcela přirozeně ho začlenit do kolekce rout. Router je implementací rozhraní [Router |api:Nette\Routing\Router] se dvěma metodami:

```php
use Nette\Http\IRequest as HttpRequest;
use Nette\Http\UrlScript;

class MyRouter implements Nette\Routing\Router
{
	public function match(HttpRequest $httpRequest): ?array
	{
		// ...
	}

	public function constructUrl(array $params, UrlScript $refUrl): ?string
	{
		// ...
	}
}
```

Metoda `match` zpracuje aktuální požadavek [$httpRequest |api:Nette\Http\Request] (ze kterého lze získat nejen URL) do pole obsahující jméno presenteru a jeho parametry. Pokud požadavek zpracovat neumí, vrátí null.

Metoda `constructUrl` naopak sestaví z pole parametrů výsledné absolutní URL. K tomu může využít informace z parametru `$refUrl`.

Možnosti vlastního routeru jsou prakticky neomezené, lze třeba implementovat router, který bude routovat na základě databázové tabulky.


Samostatné použití
==================

TODO

{{composer: nette/application}}
